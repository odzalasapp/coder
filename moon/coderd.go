package moon

import (
	"context"
	"net/http"
	"net/url"
	"regexp"
	"sync"

	"github.com/coder/coder/codersdk"

	"github.com/coder/coder/coderd/wsconncache"

	"github.com/coder/coder/coderd/workspaceproxy"

	"github.com/coder/coder/coderd/httpapi"

	"github.com/coder/coder/tailnet"
	"github.com/go-chi/chi/v5"
	"go.opentelemetry.io/otel/trace"

	"tailscale.com/derp"
	"tailscale.com/derp/derphttp"
	"tailscale.com/types/key"

	"cdr.dev/slog"
)

type Options struct {
	PrimaryURL *url.URL
	// AccessURL is the URL of the WorkspaceProxy instance.
	AccessURL *url.URL
	// AppHostname should be the wildcard hostname to use for workspace
	// applications INCLUDING the asterisk, (optional) suffix and leading dot.
	// It will use the same scheme and port number as the access URL.
	// E.g. "*.apps.coder.com" or "*-apps.coder.com".
	AppHostname string
	// AppHostnameRegex contains the regex version of options.AppHostname as
	// generated by httpapi.CompileHostnamePattern(). It MUST be set if
	// options.AppHostname is set.
	AppHostnameRegex *regexp.Regexp
	Logger           slog.Logger
	TracerProvider   trace.TracerProvider
	DERPServer       *derp.Server

	HTTPClient *http.Client
}

type Proxy struct {
	// ctx is canceled immediately on shutdown, it can be used to abort
	// interruptible tasks.
	ctx    context.Context
	cancel context.CancelFunc

	*Options

	// RootHandler serves "/"
	RootHandler chi.Router

	WebsocketWaitMutex sync.Mutex
	WebsocketWaitGroup sync.WaitGroup
	derpCloseFunc      func()

	Proxy *workspaceproxy.Proxy
}

func New(options *Options) *Proxy {
	if options == nil {
		options = &Options{}
	}

	if options.AppHostname != "" && options.AppHostnameRegex == nil || options.AppHostname == "" && options.AppHostnameRegex != nil {
		panic("coderd: both AppHostname and AppHostnameRegex must be set or unset")
	}

	if options.DERPServer != nil {
		options.DERPServer = derp.NewServer(key.NewNode(), tailnet.Logger(options.Logger.Named("derp")))
	}
	derpHandler := derphttp.Handler(options.DERPServer)
	derpHandler, derpCloseFunc := tailnet.WithWebsocketSupport(options.DERPServer, derpHandler)

	router := chi.NewRouter()
	ctx, cancel := context.WithCancel(context.Background())
	proxy := &Proxy{
		Options:            options,
		ctx:                ctx,
		cancel:             cancel,
		WebsocketWaitMutex: sync.Mutex{},
		WebsocketWaitGroup: sync.WaitGroup{},
		derpCloseFunc:      derpCloseFunc,
		RootHandler:        router,
	}

	client := codersdk.New(options.PrimaryURL)
	proxy.Proxy = workspaceproxy.New(&workspaceproxy.Options{
		WebsocketWaitMutex:    &proxy.WebsocketWaitMutex,
		WebsocketWaitGroup:    &proxy.WebsocketWaitGroup,
		WorkspaceAppsProvider: nil,
		WorkspaceAgentCache:   wsconncache.New(client.Dial, 0),
	})

	// TODO: Maybe we should attach the routes to a router that is passed in
	router.Route("/api/v2", func(r chi.Router) {
		r.NotFound(func(rw http.ResponseWriter, r *http.Request) { httpapi.RouteNotFound(rw) })
		r.Route("/workspaceagents", func(r chi.Router) {
			r.Get("/{workspaceagent}/pty", proxy.Proxy.WorkspaceAgentPTY)
		})
	})

	return proxy
}

// Close waits for all WebSocket connections to drain before returning.
func (api *Proxy) Close() error {
	api.cancel()
	api.derpCloseFunc()

	api.WebsocketWaitMutex.Lock()
	api.WebsocketWaitGroup.Wait()
	api.WebsocketWaitMutex.Unlock()

	//api.metricsCache.Close()
	//if api.updateChecker != nil {
	//	api.updateChecker.Close()
	//}
	//coordinator := api.TailnetCoordinator.Load()
	//if coordinator != nil {
	//	_ = (*coordinator).Close()
	//}
	//return api.workspaceAgentCache.Close()
	return nil
}
